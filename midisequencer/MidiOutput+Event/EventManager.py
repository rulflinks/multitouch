import EventWorkerimport Outputimport timeimport threading import Queue''' - Class: EventManager- Description:This class is the worker's manager. Here we can register new objectswith callback functions while the worker is busy working'''class EventManager(threading.Thread):	def __init__(self, **kwargs):		kwargs.setdefault('logging', True)		self.__logging = kwargs.get('logging')		self.__log('initializing EventManager')				# thread safe queue for music data		self.playDataQueue=Queue.Queue(maxsize=32)				# mandatory for threading		threading.Thread.__init__(self) 				# setup worker		self.worker=EventWorker.EventWorker(manager=self, logging=self.__logging)		self.worker.setDaemon(True)				# setup output		self.output=Output.Output(manager=self, logging=self.__logging)		self.output.setDaemon(True)				self.__callbacks={} # dictionary for callback methods <obj>:<callback>	''' register an object '''	def register(self, object, method):		self.__log('registering callback method for ' + object.id)		self.__callbacks[object]=method				# tell worker to get new registered method:		self.worker.refreshConfig.set()			''' for EventWorker to fetch it '''	def getCallbacks(self):		return self.__callbacks			''' sets the time between 2 ticks -> speed '''	def setTicktime(self,time):		self.output.setTickTime(time)	''' tunnel for log messages '''	def __log(self, msg):		if(self.__logging):			print 'EventManager:\t' + msg			''' mainloop '''	def run(self):		# start EventWorker-Thread		self.__log('starting EventWorker-Thread')		self.worker.start()				# start Output-Thread		self.__log('starting Output-Thread')		self.output.start()